<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="2.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:strip-space elements="*" />
	<xsl:output method="text" />
	<xsl:template match="/">
		<xsl:apply-templates select="//div[@class='wiki-content'][1]" />
	</xsl:template>
	<xsl:template match="//div[@class='wiki-content'][1]">
	
<xsl:text>/*
 * Copyright 2008 The Kuali Foundation
 *
 * Licensed under the Educational Community License, Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.opensource.org/licenses/ecl1.php
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 </xsl:text>
 
<xsl:text>
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;

@XmlAccessorType(XmlAccessType.FIELD)
public class </xsl:text>
		<xsl:value-of
			select="concat(upper-case(substring(normalize-space(h2),1,1)),
             substring(normalize-space(h2),2))" />
		<xsl:text> implements Serializable {&#10;</xsl:text>
		<xsl:text>&#10;    private static final long serialVersionUID = 1L;&#10;</xsl:text>
		<xsl:for-each
			select="table[@class='structTable']/tr[position()>1]">
			<xsl:choose>
				<xsl:when
					test="normalize-space(td[@class='structAttr'])='Yes'">
					<xsl:text>&#10;    @XmlAttribute&#10;</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>&#10;    @XmlElement&#10;</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>    private </xsl:text>
			<xsl:call-template name="deriveType" />
			<xsl:text> </xsl:text>
			<xsl:value-of
				select="normalize-space(td[@class='structSName'])" />
			<xsl:text>;&#10;</xsl:text>
		</xsl:for-each>
		<!-- do getters/setters -->

		<xsl:for-each
			select="table[@class='structTable']/tr[position()>1]">
			<!-- Do Getter -->
			<xsl:text>&#10;    public </xsl:text>
			<xsl:call-template name="deriveType" />
			<xsl:text> get</xsl:text>
			<xsl:value-of
				select="concat(upper-case(substring(normalize-space(td[@class='structSName']),1,1)),
             substring(normalize-space(td[@class='structSName']),2))" />
			<xsl:text>() {&#10;</xsl:text>
			<!-- Add initialization if list -->
			<xsl:if
				test="ends-with(normalize-space(td[@class='structType']),'List')">
				<xsl:text>        if (</xsl:text>
				<xsl:value-of
					select="normalize-space(td[@class='structSName'])" />
				<xsl:text> == null) {&#10;</xsl:text>
				<xsl:text>            </xsl:text>
				<xsl:value-of
					select="normalize-space(td[@class='structSName'])" />
				<xsl:text> = new Array</xsl:text>
				<xsl:call-template name="deriveType" />
				<xsl:text>();&#10;</xsl:text>
				<xsl:text>        }&#10;</xsl:text>
			</xsl:if>
			<xsl:text>        return </xsl:text>
			<xsl:value-of
				select="normalize-space(td[@class='structSName'])" />

			<xsl:text>;&#10;</xsl:text>
			<xsl:text>    }&#10;</xsl:text>

			<!-- Do Setter -->
			<xsl:text>&#10;    public void set</xsl:text>
			<xsl:value-of
				select="concat(upper-case(substring(normalize-space(td[@class='structSName']),1,1)),
             substring(normalize-space(td[@class='structSName']),2))" />
			<xsl:text>(</xsl:text>
			<xsl:call-template name="deriveType" />
			<xsl:text> </xsl:text>
			<xsl:value-of
				select="normalize-space(td[@class='structSName'])" />
			<xsl:text>) {&#10;</xsl:text>
			<xsl:text>        this.</xsl:text>
			<xsl:value-of
				select="normalize-space(td[@class='structSName'])" />
			<xsl:text> = </xsl:text>
			<xsl:value-of
				select="normalize-space(td[@class='structSName'])" />
			<xsl:text>;&#10;</xsl:text>
			<xsl:text>    }&#10;</xsl:text>
		</xsl:for-each>

		<xsl:text>}</xsl:text>
	</xsl:template>
	<xsl:template name="deriveType">
		<xsl:choose>
			<xsl:when
				test="ends-with(normalize-space(td[@class='structType']),'List')">
				<xsl:text>List&lt;</xsl:text>
				<xsl:value-of
					select="concat(upper-case(substring(normalize-space(td[@class='structType']),1,1)),
             substring(normalize-space(td[@class='structType']),2,string-length(normalize-space(td[@class='structType']))-5))" />
				<xsl:text>&gt;</xsl:text>
			</xsl:when>
			<xsl:when
				test="normalize-space(td[@class='structType'])='dateTime'">
				<xsl:text>Date</xsl:text>
			</xsl:when>
			<xsl:when
				test="ends-with(normalize-space(td[@class='structType']),'Id')">
				<xsl:text>String</xsl:text>
			</xsl:when>
			<xsl:when
				test="ends-with(normalize-space(td[@class='structType']),'Type')">
				<xsl:text>String</xsl:text>
			</xsl:when>
			<xsl:when
				test="ends-with(normalize-space(td[@class='structType']),'Key')">
				<xsl:text>String</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of
					select="concat(upper-case(substring(normalize-space(td[@class='structType']),1,1)),
             substring(normalize-space(td[@class='structType']),2))" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
</xsl:stylesheet>