<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="2.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:output method="text" />
	<xsl:template match="/">
	
<xsl:text>/*
 * Copyright 2008 The Kuali Foundation
 *
 * Licensed under the Educational Community License, Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.opensource.org/licenses/ecl1.php
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
 </xsl:text>
	
		<xsl:text>public interface foo {&#10;</xsl:text>
		<xsl:for-each select="contents/table">
			<xsl:text>    /** &#10;</xsl:text>
			<xsl:text>     * </xsl:text>
			<xsl:value-of
				select="normalize-space(tr/td[@class='methodDesc'])" />
			<xsl:text>&#10;</xsl:text>
			<xsl:for-each select="tr/td[@class='methodParamName']">
				<xsl:if test=". ne 'None'">
					<xsl:text>     * @param </xsl:text>
					<xsl:value-of select="normalize-space(.)" />
					<xsl:text> </xsl:text>
					<xsl:value-of
						select="normalize-space(parent::*/td[@class='methodParamDesc'])" />
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
			</xsl:for-each>
			<xsl:text>     * @return </xsl:text>
			<xsl:value-of
				select="normalize-space(tr/td[@class='methodReturnDesc'])" />
			<xsl:text>&#10;</xsl:text>
			<xsl:for-each select="tr/td[@class='methodErrorType']">
				<xsl:text>     * @throws </xsl:text>
				<xsl:value-of
					select="normalize-space(string-join((for $word in tokenize(.,'_')[position() > 0] return concat(upper-case(substring($word,1,1)), lower-case(substring($word,2)))),''))" />
				<xsl:text>Exception </xsl:text>
				<xsl:value-of
					select="normalize-space(parent::*/td[@class='methodErrorDesc'])" />
				<xsl:text>&#10;</xsl:text>
			</xsl:for-each>
			<xsl:text>	 */&#10;</xsl:text>
			<xsl:text>    public </xsl:text>
			<xsl:call-template name="deriveType">
				<xsl:with-param name="type">
					<xsl:value-of
						select="normalize-space(tr/td[@class='methodReturnType'])" />
				</xsl:with-param>
			</xsl:call-template>
			<xsl:text> </xsl:text>
			<xsl:value-of
				select="normalize-space(tr/td[@class='methodName'])" />
			<xsl:text>(</xsl:text>
			<xsl:apply-templates
				select="tr[td[@class='methodParamType']]" />
			<xsl:text>)</xsl:text>
			<xsl:apply-templates
				select="tr[td[@class='methodErrorType']]" />
			<xsl:text>;&#10;&#10;</xsl:text>
		</xsl:for-each>
		<xsl:text>}</xsl:text>
	</xsl:template>
	<xsl:template match="tr[td[@class='methodParamType']]">
		<xsl:if test="td[@class='methodParamName'] ne 'None'">
			<xsl:if
				test="count(preceding-sibling::tr[td[@class='methodParamType']]) gt 0">
				<xsl:text>, </xsl:text>
			</xsl:if>
			<xsl:text>@WebParam(name="</xsl:text>
			<xsl:value-of
				select="normalize-space(td[@class='methodParamName'])" />
			<xsl:text>")</xsl:text>
			<xsl:call-template name="deriveType">
				<xsl:with-param name="type">
					<xsl:value-of
						select="normalize-space(td[@class='methodParamType'])" />
				</xsl:with-param>
			</xsl:call-template>
			<xsl:text> </xsl:text>
			<xsl:value-of
				select="normalize-space(td[@class='methodParamName'])" />
		</xsl:if>
	</xsl:template>
	<xsl:template match="tr[td[@class='methodErrorType']]">
		<xsl:if test="td[@class='methodErrorType'] ne 'None'">
			<xsl:if
				test="count(preceding-sibling::tr[td[@class='methodErrorType']]) gt 0">
				<xsl:text>, </xsl:text>
			</xsl:if>
			<xsl:if
				test="count(preceding-sibling::tr[td[@class='methodErrorType']]) eq 0">
				<xsl:text> throws </xsl:text>
			</xsl:if>
			<xsl:value-of
				select="normalize-space(string-join((for $word in tokenize(td[@class='methodErrorType'],'_')[position() > 0] return concat(upper-case(substring($word,1,1)), lower-case(substring($word,2)))),''))" />
			<xsl:text>Exception</xsl:text>
		</xsl:if>
	</xsl:template>
	<xsl:template name="deriveType">
		<xsl:param name="type" />
		<xsl:choose>
			<xsl:when test="ends-with($type,'List')">
				<xsl:text>List&lt;</xsl:text>
				<xsl:call-template name="deriveType">
					<xsl:with-param name="type">
						<xsl:value-of
							select="substring-before($type,'List')" />
					</xsl:with-param>
				</xsl:call-template>
				<xsl:text>&gt;</xsl:text>
			</xsl:when>
			<xsl:when
				test="$type='dateTime'">
				<xsl:text>Date</xsl:text>
			</xsl:when>
			<xsl:when
				test="ends-with($type,'Key')">
				<xsl:text>String</xsl:text>
			</xsl:when>
			<xsl:when
				test="ends-with($type,'Id')">
				<xsl:text>String</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of
					select="normalize-space(concat(upper-case(substring($type,1,1)),substring($type,2)))" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
</xsl:stylesheet>